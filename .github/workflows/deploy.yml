name: Deploy to EC2

on:
  push:
    branches: ["main"]

# Necesario para publicar la imagen en GHCR con GITHUB_TOKEN
permissions:
  contents: read
  packages: write

env:
  # ---- Ajustá si cambian ----
  EC2_HOST: ec2-18-116-90-219.us-east-2.compute.amazonaws.com
  EC2_USER: ubuntu
  REMOTE_APP_DIR: /home/ubuntu/SmartFocus
  # ---------------------------

concurrency:
  group: deploy-prod
  cancel-in-progress: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Nombre de imagen en minúsculas (GHCR lo exige)
      - name: Compute lowercase IMAGE_NAME
        run: |
          echo "IMAGE_NAME=$(echo ghcr.io/${{ github.repository_owner }}/smartfocus-backend | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      # ---------- CI: Build & Push a GHCR ----------
      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & Push backend image
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          build-args: |
            COMMIT_SHA=${{ github.sha }}
          tags: |
            ${{ env.IMAGE_NAME }}:sha-${{ github.sha }}
            ${{ env.IMAGE_NAME }}:latest
          cache-from: type=registry,ref=${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.IMAGE_NAME }}:buildcache,mode=max

      # (Visibilidad) Digest de la imagen construida
      - name: Show built image digest
        run: docker buildx imagetools inspect "${{ env.IMAGE_NAME }}:sha-${{ github.sha }}"

      # ---------- CD: Deploy en EC2 ----------
      - name: Add EC2 host to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H "${{ env.EC2_HOST }}" >> ~/.ssh/known_hosts

      - name: Write SSH key from EC2_SSH_KEY (fix CRLF + perms)
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" | tr -d '\r' > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

      - name: Generate .env from Secrets
        run: |
          cat > .env << 'EOF'
          # ====== Database ======
          DB_USER=${{ secrets.DB_USER }}
          DB_PASS=${{ secrets.DB_PASS }}
          DB_HOST=db
          DB_PORT=5432
          DB_NAME=${{ secrets.DB_NAME }}

          # ====== App / Auth ======
          JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
          JWT_ALGORITHM=HS256
          ACCESS_TOKEN_EXPIRE_MINUTES=120

          # ====== Gemini ======
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          GEMINI_MODEL=
          EOF

      - name: Ensure remote folder
        run: |
          ssh -i ~/.ssh/id_ed25519 -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes \
            "${{ env.EC2_USER }}@${{ env.EC2_HOST }}" "mkdir -p '${{ env.REMOTE_APP_DIR }}'"

      - name: Copy .env to EC2
        run: |
          scp -i ~/.ssh/id_ed25519 -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes \
            .env "${{ env.EC2_USER }}@${{ env.EC2_HOST }}:${{ env.REMOTE_APP_DIR }}/.env"

      # Deploy con verificación de imagen y recreación forzada del backend
      - name: Remote deploy (pull & up, verify, prune)
        run: |
          ssh -i ~/.ssh/id_ed25519 -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes \
            "${{ env.EC2_USER }}@${{ env.EC2_HOST }}" bash -s <<'EOSSH'
          set -euo pipefail

          APP_DIR="/home/ubuntu/SmartFocus"
          cd "$APP_DIR"

          # ====== 1) Variables de imagen del workflow ======
          IMAGE_NAME='${{ env.IMAGE_NAME }}'
          IMAGE_TAG="sha-${{ github.sha }}"
          echo ">> Target image: $IMAGE_NAME:$IMAGE_TAG"

          # ====== 2) Evitar que .env pise IMAGE_* (sanear si existen) ======
          if [ -f .env ]; then
            if grep -qE '^(IMAGE_NAME|IMAGE_TAG)=' .env; then
              echo ">> Sanitizing .env: removing IMAGE_* lines"
              tmpfile="$(mktemp)"
              grep -vE '^(IMAGE_NAME|IMAGE_TAG)=' .env > "$tmpfile" && mv "$tmpfile" .env
            fi
            chmod 600 .env || true
            chown "$(id -un)":"$(id -gn)" .env || true
          fi

          # ====== 3) Qué ve compose (conf renderizada)
          echo ">> docker compose config (image lines):"
          IMAGE_NAME="$IMAGE_NAME" IMAGE_TAG="$IMAGE_TAG" docker compose config | grep -i 'image:' || true

          # ====== 4) Login GHCR y pull explícito ======
          echo '${{ secrets.GHCR_TOKEN }}' | docker login ghcr.io -u 'InakiMerino0' --password-stdin
          echo ">> docker pull $IMAGE_NAME:$IMAGE_TAG"
          docker pull "$IMAGE_NAME:$IMAGE_TAG"

          # ====== 5) Recreate backend con esa imagen sí o sí ======
          echo ">> up --no-deps --force-recreate --pull always backend"
          IMAGE_NAME="$IMAGE_NAME" IMAGE_TAG="$IMAGE_TAG" \
            docker compose up -d --no-deps --force-recreate --pull always backend

          # ====== 6) Mostrar imagen realmente usada (digest) ======
          echo ">> docker compose images:"
          docker compose images || true
          echo ">> backend container image digest:"
          cid="$(docker compose ps -q backend || true)"
          if [ -n "$cid" ]; then
            img="$(docker inspect -f '{{.Image}}' "$cid")"
            docker image inspect "$img" --format '{{.Id}} {{index .RepoDigests 0}}' || true
          fi

          # ====== 7) Limpieza ======
          docker container prune -f
          docker image prune -a -f
          docker network prune -f
          EOSSH
